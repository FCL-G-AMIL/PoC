{"version":3,"file":"icon-manager.44d6d2bd.js","sources":["../../src/layers/moving-icons/icon-layer.glsl.vert?raw","../../src/layers/moving-icons/icon-layer.glsl.frag?raw","../../src/layers/moving-icons/icon-manager.ts"],"sourcesContent":["export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\r\\n//\\r\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in\\r\\n// all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\r\\n// THE SOFTWARE.\\r\\n\\r\\n#define SHADER_NAME icon-layer-vertex-shader\\r\\n\\r\\nattribute vec2 positions;\\r\\n\\r\\nattribute float instanceSizes;\\r\\nattribute vec4 instanceColors;\\r\\nattribute vec3 instancePickingColors;\\r\\nattribute vec4 instanceIconFrames;\\r\\nattribute float instanceColorModes;\\r\\nattribute vec2 instanceOffsets;\\r\\nattribute vec2 instancePixelOffset;\\r\\n\\r\\nuniform float sizeScale;\\r\\nuniform vec2 iconsTextureDim;\\r\\nuniform float sizeMinPixels;\\r\\nuniform float sizeMaxPixels;\\r\\nuniform bool billboard;\\r\\n\\r\\nuniform float currentTime;\\r\\n\\r\\nuniform vec2 iconStillOffsets;\\r\\nuniform vec4 iconStillFrames;\\r\\n\\r\\nattribute float instanceTimestamps;\\r\\nattribute float instanceTimestampsNext;\\r\\nattribute vec2 instanceStartPositions;\\r\\nattribute vec2 instanceEndPositions;\\r\\n\\r\\nvarying float vColorMode;\\r\\nvarying vec4 vColor;\\r\\nvarying vec2 vTextureCoords;\\r\\nvarying vec2 uv;\\r\\nvarying float vPercentComplete;\\r\\n\\r\\n// ------------------------------------------------------------------\\r\\n\\r\\nvec2 rotate_by_angle(vec2 vertex, float angle_radian) {\\r\\n  float cos_angle = cos(angle_radian);\\r\\n  float sin_angle = sin(angle_radian);\\r\\n  mat2 rotationMatrix = mat2(cos_angle, -sin_angle, sin_angle, cos_angle);\\r\\n  return rotationMatrix * vertex;\\r\\n}\\r\\n\\r\\nvec3 interpolate(in vec3 point1, in vec3 point2, in float timestepFraction) {\\r\\n    if (timestepFraction <= 0.0) {\\r\\n        return point1;\\r\\n    } else if (timestepFraction >= 1.0 ) {\\r\\n        return point2;\\r\\n    } else {\\r\\n        vec3 direction = point2 - point1;\\r\\n        return point1 + (direction * timestepFraction);\\r\\n    }\\r\\n}\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  // Calculate progress:\\r\\n  // Skip everything else if this vertex is outside the time window\\r\\n  if (currentTime < instanceTimestamps) {\\r\\n    vPercentComplete = -1.0;\\r\\n    return;\\r\\n  } else if (currentTime > instanceTimestampsNext) {\\r\\n    vPercentComplete = -1.0;\\r\\n    return;\\r\\n  } else {\\r\\n    vPercentComplete = (currentTime - instanceTimestamps) /\\r\\n                       (instanceTimestampsNext - instanceTimestamps);\\r\\n  }\\r\\n\\r\\n  geometry.pickingColor = instancePickingColors;\\r\\n\\r\\n  vec3 startPosition = vec3(instanceStartPositions, 5.0);\\r\\n  vec3 endPosition = vec3(instanceEndPositions, 5.0);\\r\\n\\r\\n  // are we stationary/still\\r\\n  bool still = (instanceStartPositions == instanceEndPositions);\\r\\n\\r\\n  // geometry.uv = positions;\\r\\n  // uv = positions;\\r\\n\\r\\n  // this could be the problem right here;\\r\\n  vec2 iconSize = still ? iconStillFrames.zw : instanceIconFrames.zw;\\r\\n  // convert size in meters to pixels, then scaled and clamp\\r\\n  // project meters to pixels and clamp to limits\\r\\n  float sizePixels = clamp(\\r\\n    project_size_to_pixel(instanceSizes * sizeScale),\\r\\n    sizeMinPixels, sizeMaxPixels\\r\\n  );\\r\\n\\r\\n  // scale icon height to match instanceSize\\r\\n  float instanceScale = iconSize.y == 0.0 ? 0.0 : sizePixels / iconSize.y;\\r\\n\\r\\n  // // figure out angle based on motion direction\\r\\n  float angle = 0.0;\\r\\n  if (!still) {\\r\\n    vec3 direction = normalize(endPosition - startPosition);\\r\\n    angle = atan( direction.y / direction.x);\\r\\n    if (direction.x < 0.0) angle = angle - PI;\\r\\n  }\\r\\n\\r\\n  // scale and rotate vertex in \\\"pixel\\\" value and convert back to fraction in clipspace\\r\\n  vec2 pixelOffset = positions / 2.0 * iconSize + (still ? iconStillOffsets : instanceOffsets);\\r\\n  pixelOffset = rotate_by_angle(pixelOffset, angle) * instanceScale;\\r\\n  pixelOffset += instancePixelOffset;\\r\\n  pixelOffset.y *= -1.0;\\r\\n\\r\\n  vec3 newPosition = interpolate(startPosition, endPosition, vPercentComplete);\\r\\n\\r\\n  if (billboard)  {\\r\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), vec3(0.0), geometry.position);\\r\\n    vec3 offset = vec3(pixelOffset, 0.0);\\r\\n    DECKGL_FILTER_SIZE(offset, geometry);\\r\\n    gl_Position.xy += project_pixel_size_to_clipspace(offset.xy);\\r\\n\\r\\n  } else {\\r\\n    vec3 offset_common = vec3(project_pixel_size(pixelOffset), 0.0);\\r\\n    DECKGL_FILTER_SIZE(offset_common, geometry);\\r\\n    gl_Position = project_position_to_clipspace(newPosition, vec3(0.0), offset_common, geometry.position);\\r\\n  }\\r\\n  DECKGL_FILTER_GL_POSITION(gl_Position, geometry);\\r\\n\\r\\n  vec2 upperleft = (still ? iconStillFrames.xy : instanceIconFrames.xy);\\r\\n\\r\\n  vTextureCoords = mix(\\r\\n    upperleft,\\r\\n    upperleft + iconSize,\\r\\n    (positions.xy + 1.0) / 2.0\\r\\n  ) / iconsTextureDim;\\r\\n\\r\\n  vColor = instanceColors;\\r\\n  DECKGL_FILTER_COLOR(vColor, geometry);\\r\\n\\r\\n  vColorMode = instanceColorModes;\\r\\n}\\r\\n\"","export default \"// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\\r\\n//\\r\\n// Copyright (c) 2015 - 2017 Uber Technologies, Inc.\\r\\n//\\r\\n// Permission is hereby granted, free of charge, to any person obtaining a copy\\r\\n// of this software and associated documentation files (the \\\"Software\\\"), to deal\\r\\n// in the Software without restriction, including without limitation the rights\\r\\n// to use, copy, modify, merge, publish, distribute, sublicense, and/or sell\\r\\n// copies of the Software, and to permit persons to whom the Software is\\r\\n// furnished to do so, subject to the following conditions:\\r\\n//\\r\\n// The above copyright notice and this permission notice shall be included in\\r\\n// all copies or substantial portions of the Software.\\r\\n//\\r\\n// THE SOFTWARE IS PROVIDED \\\"AS IS\\\", WITHOUT WARRANTY OF ANY KIND, EXPRESS OR\\r\\n// IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF MERCHANTABILITY,\\r\\n// FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN NO EVENT SHALL THE\\r\\n// AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER\\r\\n// LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM,\\r\\n// OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN\\r\\n// THE SOFTWARE.\\r\\n\\r\\n#define SHADER_NAME icon-layer-fragment-shader\\r\\n\\r\\nprecision highp float;\\r\\n\\r\\nuniform float opacity;\\r\\nuniform sampler2D iconsTexture;\\r\\nuniform float alphaCutoff;\\r\\n\\r\\nvarying float vColorMode;\\r\\nvarying vec4 vColor;\\r\\nvarying vec2 vTextureCoords;\\r\\nvarying vec2 uv;\\r\\n\\r\\nuniform float currentTime;\\r\\nvarying float vPercentComplete;\\r\\n\\r\\nvoid main(void) {\\r\\n\\r\\n  if (vPercentComplete == -1.0) discard;\\r\\n\\r\\n  geometry.uv = uv;\\r\\n\\r\\n  vec4 texColor = texture2D(iconsTexture, vTextureCoords);\\r\\n\\r\\n  // if colorMode == 0, use pixel color from the texture\\r\\n  // if colorMode == 1 or rendering picking buffer, use texture as transparency mask\\r\\n  vec3 color = mix(texColor.rgb, vColor.rgb, vColorMode);\\r\\n  // Take the global opacity and the alpha from vColor into account for the alpha component\\r\\n  float a = texColor.a * opacity * vColor.a;\\r\\n\\r\\n  if (a < alphaCutoff) {\\r\\n    discard;\\r\\n  }\\r\\n\\r\\n  gl_FragColor = vec4(color, a);\\r\\n  DECKGL_FILTER_COLOR(gl_FragColor, geometry);\\r\\n}\\r\\n\"","// BC 2021-04-30: this file forked from https://github.com/visgl/deck.gl\r\n//\r\n/* global document */\r\nimport GL from '@luma.gl/constants'\r\nimport { Texture2D, copyToTexture, cloneTextureFrom } from '@luma.gl/core'\r\nimport { ImageLoader } from '@loaders.gl/images'\r\nimport { load } from '@loaders.gl/core'\r\nimport { createIterable } from '@deck.gl/core'\r\n\r\nconst DEFAULT_CANVAS_WIDTH = 1024\r\nconst DEFAULT_BUFFER = 4\r\n\r\nconst noop = () => {}\r\n\r\nconst DEFAULT_TEXTURE_PARAMETERS = {\r\n  [GL.TEXTURE_MIN_FILTER]: GL.LINEAR_MIPMAP_LINEAR,\r\n  // GL.LINEAR is the default value but explicitly set it here\r\n  [GL.TEXTURE_MAG_FILTER]: GL.LINEAR,\r\n  // for texture boundary artifact\r\n  [GL.TEXTURE_WRAP_S]: GL.CLAMP_TO_EDGE,\r\n  [GL.TEXTURE_WRAP_T]: GL.CLAMP_TO_EDGE,\r\n}\r\n\r\nfunction nextPowOfTwo(number: number) {\r\n  return Math.pow(2, Math.ceil(Math.log2(number)))\r\n}\r\n\r\n// update comment to create a new texture and copy original data.\r\nfunction resizeImage(ctx: any, imageData: any, width: any, height: any) {\r\n  if (width === imageData.width && height === imageData.height) {\r\n    return imageData\r\n  }\r\n\r\n  ctx.canvas.height = height\r\n  ctx.canvas.width = width\r\n\r\n  ctx.clearRect(0, 0, ctx.canvas.width, ctx.canvas.height)\r\n\r\n  // image, sx, sy, sWidth, sHeight, dx, dy, dWidth, dHeight\r\n  ctx.drawImage(imageData, 0, 0, imageData.width, imageData.height, 0, 0, width, height)\r\n\r\n  return ctx.canvas\r\n}\r\n\r\nfunction getIconId(icon: any) {\r\n  return icon && (icon.id || icon.url)\r\n}\r\n\r\n// resize texture without losing original data\r\nfunction resizeTexture(gl: any, texture: any, width: any, height: any) {\r\n  const oldWidth = texture.width\r\n  const oldHeight = texture.height\r\n\r\n  const newTexture = cloneTextureFrom(texture, { width, height })\r\n  copyToTexture(texture, newTexture, {\r\n    targetY: 0,\r\n    width: oldWidth,\r\n    height: oldHeight,\r\n  })\r\n\r\n  texture.delete()\r\n  return newTexture\r\n}\r\n\r\n// traverse icons in a row of icon atlas\r\n// extend each icon with left-top coordinates\r\nfunction buildRowMapping(mapping: any, columns: any, yOffset: any) {\r\n  for (let i = 0; i < columns.length; i++) {\r\n    const { icon, xOffset } = columns[i]\r\n    const id = getIconId(icon)\r\n    mapping[id] = {\r\n      ...icon,\r\n      x: xOffset,\r\n      y: yOffset,\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Generate coordinate mapping to retrieve icon left-top position from an icon atlas\r\n * @param icons {Array<Object>} list of icons, each icon requires url, width, height\r\n * @param buffer {Number} add buffer to the right and bottom side of the image\r\n * @param xOffset {Number} right position of last icon in old mapping\r\n * @param yOffset {Number} top position in last icon in old mapping\r\n * @param rowHeight {Number} rowHeight of the last icon's row\r\n * @param canvasWidth {Number} max width of canvas\r\n * @param mapping {object} old mapping\r\n * @returns {{mapping: {'/icon/1': {url, width, height, ...}},, canvasHeight: {Number}}}\r\n */\r\nexport function buildMapping({\r\n  icons,\r\n  buffer,\r\n  mapping = {},\r\n  xOffset = 0,\r\n  yOffset = 0,\r\n  rowHeight = 0,\r\n  canvasWidth,\r\n}: any) {\r\n  let columns = []\r\n  // Strategy to layout all the icons into a texture:\r\n  // traverse the icons sequentially, layout the icons from left to right, top to bottom\r\n  // when the sum of the icons width is equal or larger than canvasWidth,\r\n  // move to next row starting from total height so far plus max height of the icons in previous row\r\n  // row width is equal to canvasWidth\r\n  // row height is decided by the max height of the icons in that row\r\n  // mapping coordinates of each icon is its left-top position in the texture\r\n  for (let i = 0; i < icons.length; i++) {\r\n    const icon = icons[i]\r\n    const id = getIconId(icon)\r\n\r\n    if (!mapping[id]) {\r\n      const { height, width } = icon\r\n\r\n      // fill one row\r\n      if (xOffset + width + buffer > canvasWidth) {\r\n        buildRowMapping(mapping, columns, yOffset)\r\n\r\n        xOffset = 0\r\n        yOffset = rowHeight + yOffset + buffer\r\n        rowHeight = 0\r\n        columns = []\r\n      }\r\n\r\n      columns.push({\r\n        icon,\r\n        xOffset,\r\n      })\r\n\r\n      xOffset = xOffset + width + buffer\r\n      rowHeight = Math.max(rowHeight, height)\r\n    }\r\n  }\r\n\r\n  if (columns.length > 0) {\r\n    buildRowMapping(mapping, columns, yOffset)\r\n  }\r\n\r\n  return {\r\n    mapping,\r\n    rowHeight,\r\n    xOffset,\r\n    yOffset,\r\n    canvasWidth,\r\n    canvasHeight: nextPowOfTwo(rowHeight + yOffset + buffer),\r\n  }\r\n}\r\n\r\n// extract icons from data\r\n// return icons should be unique, and not cached or cached but url changed\r\nexport function getDiffIcons(data: any, getIcon: any, cachedIcons: any) {\r\n  if (!data || !getIcon) {\r\n    return null\r\n  }\r\n\r\n  cachedIcons = cachedIcons || {}\r\n  const icons = {} as any\r\n  const { iterable, objectInfo } = createIterable(data)\r\n  for (const object of iterable) {\r\n    objectInfo.index++\r\n    const icon = getIcon(object, objectInfo)\r\n    const id = getIconId(icon)\r\n\r\n    if (!icon) {\r\n      throw new Error('Icon is missing.')\r\n    }\r\n\r\n    if (!icon.url) {\r\n      throw new Error('Icon url is missing.')\r\n    }\r\n\r\n    if (!icons[id] && (!cachedIcons[id] || icon.url !== cachedIcons[id].url)) {\r\n      icons[id] = { ...icon, source: object, sourceIndex: objectInfo.index }\r\n    }\r\n  }\r\n  return icons\r\n}\r\n\r\nexport default class IconManager {\r\n  gl: any\r\n  onUpdate: () => void\r\n  onError: (e: any) => any\r\n  _loadOptions: any\r\n  _getIcon: any\r\n  _texture: any\r\n  _externalTexture: any\r\n  _mapping: any\r\n  _pendingCount: number\r\n  _autoPacking: boolean\r\n  _xOffset: number\r\n  _yOffset: number\r\n  _rowHeight: number\r\n  _buffer: number\r\n  _canvasWidth: number\r\n  _canvasHeight: number\r\n  _canvas: any\r\n\r\n  constructor(\r\n    gl: any,\r\n    {\r\n      onUpdate = noop, // notify IconLayer when icon texture update\r\n      onError = noop,\r\n    }\r\n  ) {\r\n    this.gl = gl\r\n    this.onUpdate = onUpdate\r\n    this.onError = onError\r\n\r\n    // load options used for loading images\r\n    this._loadOptions = null\r\n    this._getIcon = null\r\n\r\n    this._texture = null\r\n    this._externalTexture = null\r\n    this._mapping = {}\r\n    // count of pending requests to fetch icons\r\n    this._pendingCount = 0\r\n\r\n    this._autoPacking = false\r\n\r\n    // internal props used when autoPacking applied\r\n    // right position of last icon\r\n    this._xOffset = 0\r\n    // top position of last icon\r\n    this._yOffset = 0\r\n    this._rowHeight = 0\r\n    this._buffer = DEFAULT_BUFFER\r\n    this._canvasWidth = DEFAULT_CANVAS_WIDTH\r\n    this._canvasHeight = 0\r\n    this._canvas = null\r\n  }\r\n\r\n  finalize() {\r\n    this._texture?.delete()\r\n  }\r\n\r\n  getTexture() {\r\n    return this._texture || this._externalTexture\r\n  }\r\n\r\n  getIconMapping(icon: any) {\r\n    const id = this._autoPacking ? getIconId(icon) : icon\r\n    return this._mapping[id] || {}\r\n  }\r\n\r\n  setProps({ loadOptions, autoPacking, iconAtlas, iconMapping, data, getIcon }: any) {\r\n    if (loadOptions) {\r\n      this._loadOptions = loadOptions\r\n    }\r\n\r\n    if (autoPacking !== undefined) {\r\n      this._autoPacking = autoPacking\r\n    }\r\n\r\n    if (getIcon) {\r\n      this._getIcon = getIcon\r\n    }\r\n\r\n    if (iconMapping) {\r\n      this._mapping = iconMapping\r\n    }\r\n\r\n    if (iconAtlas) {\r\n      this._updateIconAtlas(iconAtlas)\r\n    }\r\n\r\n    if (this._autoPacking && (data || getIcon) && typeof document !== 'undefined') {\r\n      this._canvas = this._canvas || document.createElement('canvas')\r\n\r\n      this._updateAutoPacking(data)\r\n    }\r\n  }\r\n\r\n  get isLoaded() {\r\n    return this._pendingCount === 0\r\n  }\r\n\r\n  _updateIconAtlas(iconAtlas: any) {\r\n    this._texture?.delete()\r\n    this._texture = null\r\n    this._externalTexture = iconAtlas\r\n    this.onUpdate()\r\n  }\r\n\r\n  _updateAutoPacking(data: any) {\r\n    const icons = Object.values(getDiffIcons(data, this._getIcon, this._mapping) || {})\r\n\r\n    if (icons.length > 0) {\r\n      // generate icon mapping\r\n      const { mapping, xOffset, yOffset, rowHeight, canvasHeight } = buildMapping({\r\n        icons,\r\n        buffer: this._buffer,\r\n        canvasWidth: this._canvasWidth,\r\n        mapping: this._mapping,\r\n        rowHeight: this._rowHeight,\r\n        xOffset: this._xOffset,\r\n        yOffset: this._yOffset,\r\n      })\r\n\r\n      this._rowHeight = rowHeight\r\n      this._mapping = mapping\r\n      this._xOffset = xOffset\r\n      this._yOffset = yOffset\r\n      this._canvasHeight = canvasHeight\r\n\r\n      // create new texture\r\n      if (!this._texture) {\r\n        this._texture = new Texture2D(this.gl, {\r\n          width: this._canvasWidth,\r\n          height: this._canvasHeight,\r\n          parameters: DEFAULT_TEXTURE_PARAMETERS,\r\n        })\r\n      }\r\n\r\n      if (this._texture.height !== this._canvasHeight) {\r\n        this._texture = resizeTexture(this.gl, this._texture, this._canvasWidth, this._canvasHeight)\r\n      }\r\n\r\n      this.onUpdate()\r\n\r\n      // load images\r\n      this._loadIcons(icons)\r\n    }\r\n  }\r\n\r\n  _loadIcons(icons: any) {\r\n    const ctx = this._canvas.getContext('2d')\r\n\r\n    for (const icon of icons) {\r\n      this._pendingCount++\r\n      load(icon.url, ImageLoader, this._loadOptions)\r\n        .then(imageData => {\r\n          const id = getIconId(icon)\r\n          const { x, y, width, height } = this._mapping[id]\r\n\r\n          const data = resizeImage(ctx, imageData, width, height)\r\n\r\n          this._texture.setSubImageData({\r\n            data,\r\n            x,\r\n            y,\r\n            width,\r\n            height,\r\n          })\r\n\r\n          // Call to regenerate mipmaps after modifying texture(s)\r\n          this._texture.generateMipmap()\r\n\r\n          this.onUpdate()\r\n        })\r\n        .catch(error => {\r\n          this.onError({\r\n            url: icon.url,\r\n            source: icon.source,\r\n            sourceIndex: icon.sourceIndex,\r\n            loadOptions: this._loadOptions,\r\n            error,\r\n          })\r\n        })\r\n        .finally(() => {\r\n          this._pendingCount--\r\n        })\r\n    }\r\n  }\r\n}\r\n"],"names":["vertShader","fragShader","DEFAULT_CANVAS_WIDTH","DEFAULT_BUFFER","noop","DEFAULT_TEXTURE_PARAMETERS","GL","nextPowOfTwo","number","resizeImage","ctx","imageData","width","height","getIconId","icon","resizeTexture","gl","texture","oldWidth","oldHeight","newTexture","cloneTextureFrom","copyToTexture","buildRowMapping","mapping","columns","yOffset","i","xOffset","id","buildMapping","icons","buffer","rowHeight","canvasWidth","getDiffIcons","data","getIcon","cachedIcons","iterable","objectInfo","createIterable","object","IconManager","onUpdate","onError","_a","loadOptions","autoPacking","iconAtlas","iconMapping","canvasHeight","Texture2D","load","ImageLoader","x","y","error"],"mappings":"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"}