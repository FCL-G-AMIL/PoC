{"version":3,"file":"DashboardDataManager.6cb84912.js","sources":["../../node_modules/d3-array/src/identity.js","../../node_modules/d3-array/src/group.js","../../src/js/DashboardDataManager.ts"],"sourcesContent":["export default function identity(x) {\n  return x;\n}\n","import {InternMap} from \"internmap\";\nimport identity from \"./identity.js\";\n\nexport default function group(values, ...keys) {\n  return nest(values, identity, identity, keys);\n}\n\nexport function groups(values, ...keys) {\n  return nest(values, Array.from, identity, keys);\n}\n\nfunction flatten(groups, keys) {\n  for (let i = 1, n = keys.length; i < n; ++i) {\n    groups = groups.flatMap(g => g.pop().map(([key, value]) => [...g, key, value]));\n  }\n  return groups;\n}\n\nexport function flatGroup(values, ...keys) {\n  return flatten(groups(values, ...keys), keys);\n}\n\nexport function flatRollup(values, reduce, ...keys) {\n  return flatten(rollups(values, reduce, ...keys), keys);\n}\n\nexport function rollup(values, reduce, ...keys) {\n  return nest(values, identity, reduce, keys);\n}\n\nexport function rollups(values, reduce, ...keys) {\n  return nest(values, Array.from, reduce, keys);\n}\n\nexport function index(values, ...keys) {\n  return nest(values, identity, unique, keys);\n}\n\nexport function indexes(values, ...keys) {\n  return nest(values, Array.from, unique, keys);\n}\n\nfunction unique(values) {\n  if (values.length !== 1) throw new Error(\"duplicate key\");\n  return values[0];\n}\n\nfunction nest(values, map, reduce, keys) {\n  return (function regroup(values, i) {\n    if (i >= keys.length) return reduce(values);\n    const groups = new InternMap();\n    const keyof = keys[i++];\n    let index = -1;\n    for (const value of values) {\n      const key = keyof(value, ++index, values);\n      const group = groups.get(key);\n      if (group) group.push(value);\n      else groups.set(key, [value]);\n    }\n    for (const [key, values] of groups) {\n      groups.set(key, regroup(values, i));\n    }\n    return map(groups);\n  })(values, 0);\n}\n","/**\r\n * DashboardDataManager: this class loads, caches, and filters CSV and XML datasets\r\n * for use by dashboard charts and maps. Loosely based on the VizWit system\r\n * (see http://vizwit.io/) but we don't have a Carto database so all of the data\r\n * is stored internally in this class.\r\n *\r\n * Each tabbed dashboard should instantiate this class once, and destroy it when the dashboard\r\n * is closed. Datasets can be big, we don't want them to stick around forever!\r\n *\r\n * Data queries always return -both- the full dataset AND a filtered dataset.\r\n * That way, the filtered data can be visually layered on top of the full data.\r\n */\r\n\r\nimport { rollup } from 'd3-array'\r\n\r\nimport globalStore from '@/store'\r\nimport HTTPFileSystem from './HTTPFileSystem'\r\nimport { DataTable, DataTableColumn, DataType, FileSystemConfig, Status } from '@/Globals'\r\nimport { findMatchingGlobInFiles } from '@/js/util'\r\n\r\nimport DataFetcherWorker from '@/workers/DataFetcher.worker.ts?worker'\r\nimport RoadNetworkLoader from '@/workers/RoadNetworkLoader.worker.ts?worker'\r\n\r\ninterface configuration {\r\n  dataset: string\r\n  groupBy?: string\r\n  value?: string\r\n  usedCol?: string[]\r\n  columns?: string[]\r\n  ignoreColumns?: any[]\r\n  skipFirstRow?: boolean\r\n  useLastRow?: boolean\r\n  x?: string\r\n}\r\n\r\nexport interface FilterDefinition {\r\n  dataset: string\r\n  column: string\r\n  value: any\r\n  operator?: string\r\n  invert?: boolean\r\n  range?: boolean\r\n}\r\n\r\nexport interface NetworkLinks {\r\n  source: Float32Array\r\n  dest: Float32Array\r\n  linkIds: any[]\r\n  projection: String\r\n}\r\n\r\n// This tells us if our environment has the Chrome File System Access API, meaning we are in Chrome\r\n//@ts-ignore\r\nconst isChrome = !!window.showDirectoryPicker\r\nconst isFirefox = !isChrome\r\n\r\nexport default class DashboardDataManager {\r\n  constructor(...args: string[]) {\r\n    // hello\r\n    this.root = args.length ? args[0] : ''\r\n    this.subfolder = args.length ? args[1] : ''\r\n    this.fileApi = this._getFileSystem(this.root)\r\n  }\r\n\r\n  private files: any[] = []\r\n  private threads: Worker[] = []\r\n  private subfolder = ''\r\n  private root = ''\r\n  private fileApi: FileSystemConfig\r\n  private networks: { [id: string]: Promise<NetworkLinks> } = {}\r\n\r\n  public kill() {\r\n    for (const worker of this.threads) worker.terminate()\r\n  }\r\n\r\n  public getFilteredDataset(config: { dataset: string }): { filteredRows: any[] | null } {\r\n    if (!(config.dataset in this.datasets)) return { filteredRows: null }\r\n\r\n    const filteredRows = this.datasets[config.dataset].filteredRows\r\n    return { filteredRows }\r\n  }\r\n\r\n  public async OLDgetFiltered(config: { dataset: string; groupBy?: string; value?: string }) {\r\n    const rows = this.datasets[config.dataset].filteredRows\r\n    if (!rows) return { filteredRows: null }\r\n\r\n    // group the rows as needed\r\n    let bars: any = {}\r\n\r\n    if (config.value && config.groupBy) {\r\n      const columnValues = config.value\r\n      const columnGroups = config.groupBy\r\n      bars = rollup(\r\n        rows,\r\n        v => v.reduce((a, b) => a + b[columnValues], 0),\r\n        (d: any) => d[columnGroups] // group-by\r\n      )\r\n    } else {\r\n      // TODO need to handle non-value, non-group here\r\n    }\r\n    const x = Array.from(bars.keys())\r\n    const y = Array.from(bars.values())\r\n\r\n    // filter the rows, too\r\n\r\n    return { filteredRows: { x, y } }\r\n  }\r\n\r\n  /**\r\n   *\r\n   * @param config the configuration params from the YAML file. Must include dataset,\r\n   *               and may include other optional parameters as needed by the viz\r\n   * @returns allRows object, containing a DataTableColumn for each column in this dataset\r\n   */\r\n  public async getDataset(config: configuration, options?: { highPrecision: boolean }) {\r\n    try {\r\n      // first, get the dataset\r\n      if (!this.datasets[config.dataset]) {\r\n        console.log('load:', config.dataset)\r\n\r\n        // fetchDataset() immediately returns a Promise<>, which we await on\r\n        // so that multiple charts don't all try to fetch the dataset individually\r\n        this.datasets[config.dataset] = {\r\n          dataset: this._fetchDataset(config, options),\r\n          activeFilters: {},\r\n          filteredRows: null,\r\n          filterListeners: new Set(),\r\n        }\r\n      }\r\n\r\n      // wait for dataset to load\r\n      // (this will immediately return dataset if it is already loaded)\r\n      let myDataset = await this.datasets[config.dataset].dataset\r\n\r\n      // make a copy because each viz in a dashboard might be hacking it differently\r\n      // TODO: be more \"functional\" and return the object itself, and let views create copies if they need to\r\n      let allRows = { ...myDataset }\r\n\r\n      // remove ignored columns\r\n      if (config.ignoreColumns) {\r\n        config.ignoreColumns.forEach(column => {\r\n          delete allRows[column]\r\n        })\r\n      }\r\n\r\n      // if useLastRow, drop all rows except the last row\r\n      if (config.useLastRow) {\r\n        Object.keys(allRows).forEach(colName => {\r\n          const values = myDataset[colName].values\r\n          allRows[colName] = values[values.length - 1]\r\n        })\r\n      }\r\n\r\n      return { allRows }\r\n    } catch (e) {\r\n      // const message = '' + e\r\n      return { allRows: {} }\r\n    }\r\n  }\r\n\r\n  /**\r\n   * Convert features array from GeoJSONs and Shapefiles into DataTable\r\n   * @param filename\r\n   * @param featureProperties array of feature objects\r\n   */\r\n  public setFeatureProperties(fullpath: string, featureProperties: any[], config: any) {\r\n    const key = fullpath.substring(fullpath.lastIndexOf('/') + 1)\r\n\r\n    // merge key with keep/drop params (etc)\r\n    let fullConfig = { dataset: key }\r\n    if ('string' !== typeof config) fullConfig = Object.assign(fullConfig, config)\r\n\r\n    this.datasets[key] = {\r\n      activeFilters: {},\r\n      filteredRows: null,\r\n      filterListeners: new Set(),\r\n      dataset: new Promise<DataTable>((resolve, reject) => {\r\n        const thread = new DataFetcherWorker()\r\n        // console.log('NEW WORKER', thread)\r\n        this.threads.push(thread)\r\n\r\n        try {\r\n          thread.postMessage({ config: fullConfig, featureProperties })\r\n\r\n          thread.onmessage = e => {\r\n            thread.terminate()\r\n            if (e.data.error) {\r\n              console.log(e.data.error)\r\n              globalStore.commit('setStatus', {\r\n                type: Status.ERROR,\r\n                msg: `Problem loading properties in ${fullpath}`,\r\n                desc: 'File loaded from storage, but properties table could not be parsed',\r\n              })\r\n              reject()\r\n            }\r\n            resolve(e.data)\r\n          }\r\n        } catch (err) {\r\n          thread.terminate()\r\n          console.error(err)\r\n          reject(err)\r\n        }\r\n      }),\r\n    }\r\n    // this is a promise:\r\n    return this.datasets[key].dataset\r\n  }\r\n\r\n  /**\r\n   *  Register an existing in-memory DataTable as a dataset in this Dashboard\r\n   * @param props key, dataTable, and filename associated with this DataTable\r\n   */\r\n  public setPreloadedDataset(props: { key: string; dataTable: DataTable }) {\r\n    // let filters = {}\r\n    // if (this.datasets[props.key]) {\r\n    //   filters = this.datasets[props.key].activeFilters\r\n    // }\r\n\r\n    this.datasets[props.key] = {\r\n      dataset: new Promise<DataTable>((resolve, reject) => {\r\n        resolve(props.dataTable)\r\n      }),\r\n      activeFilters: {}, // filters,\r\n      filteredRows: null,\r\n      filterListeners: new Set(),\r\n    }\r\n  }\r\n\r\n  public async getRoadNetwork(\r\n    filename: string,\r\n    subfolder: string,\r\n    vizDetails: any,\r\n    cbStatus?: any\r\n  ) {\r\n    const path = `/${subfolder}/${filename}`\r\n    // Get the dataset the first time it is requested\r\n    if (!this.networks[path]) {\r\n      this.networks[path] = this._fetchNetwork({ subfolder, filename, vizDetails, cbStatus })\r\n    }\r\n\r\n    // wait for the worker to provide the network\r\n    let network = await this.networks[path]\r\n    return network\r\n  }\r\n\r\n  // /**\r\n  //  * Load simple dataset without grouping/filtering\r\n  //  * @param allRows Each row\r\n  //  * @returns TBD\r\n  //  */\r\n  // public loadSimple(config: configuration, allRows: any[]) {\r\n  //   // Simple requires x and columns/usedCol\r\n  //   if (!config.x || (!config.columns && !config.usedCol)) {\r\n  //     throw Error('Config requires \"x\" and \"columns\" parameters')\r\n  //   }\r\n\r\n  //   var useOwnNames = false\r\n\r\n  //   const x = [] as any[]\r\n\r\n  //   for (var i = 0; i < allRows.length; i++) {\r\n  //     if (i == 0 && config.skipFirstRow) {\r\n  //     } else {\r\n  //       x.push(allRows[i][config.x])\r\n  //     }\r\n  //   }\r\n\r\n  //   const columns = config.columns || config.usedCol || []\r\n\r\n  //   for (let i = 0; i < columns.length; i++) {\r\n  //     const name = columns[i]\r\n  //     let legendName = ''\r\n  //     if (columns[i] !== 'undefined') {\r\n  //       if (useOwnNames) {\r\n  //         legendName = this.config.legendTitles[i]\r\n  //       } else {\r\n  //         legendName = name\r\n  //       }\r\n  //       const value = []\r\n  //       for (var j = 0; j < this.dataRows.length; j++) {\r\n  //         if (j == 0 && this.config.skipFirstRow) {\r\n  //         } else {\r\n  //           value.push(this.dataRows[j][name])\r\n  //         }\r\n  //       }\r\n  //       this.data.push({\r\n  //         x: x,\r\n  //         y: value,\r\n  //         name: legendName,\r\n  //         type: 'bar',\r\n  //         textinfo: 'label+percent',\r\n  //         textposition: 'inside',\r\n  //         automargin: true,\r\n  //       })\r\n  //     }\r\n  //   }\r\n  // }\r\n\r\n  public setFilter(filter: FilterDefinition) {\r\n    const { dataset, column, value, invert, range } = filter\r\n\r\n    if (!this.datasets[dataset]) {\r\n      console.warn(`${dataset} doesn't exist yet`)\r\n      console.warn(Object.keys(this.datasets))\r\n      return\r\n    }\r\n    console.log('> setFilter', dataset, column, value)\r\n\r\n    // Filter might be single or an array; make it an array.\r\n    const values = Array.isArray(value) ? value : [value]\r\n    if (this.datasets[dataset].activeFilters == null) {\r\n      this.datasets[dataset].activeFilters = {}\r\n    }\r\n    const allFilters = this.datasets[dataset].activeFilters\r\n    // a second click on a filter means REMOVE this filter.\r\n    // if (allFilters[column] !== undefined && allFilters[column] === values) {\r\n    //   console.log('A1', allFilters[column])\r\n    //   delete allFilters[column]\r\n    // } else\r\n    if (!values.length) {\r\n      delete allFilters[column]\r\n    } else {\r\n      allFilters[column] = { values, invert, range }\r\n    }\r\n    this._updateFilters(dataset) // this is async\r\n  }\r\n\r\n  public addFilterListener(config: { dataset: string }, listener: any) {\r\n    const selectedDataset = this.datasets[config.dataset]\r\n    if (!selectedDataset) throw Error('No dataset named: ' + config.dataset)\r\n\r\n    // console.log(22, config.dataset, this.datasets[config.dataset])\r\n    this.datasets[config.dataset].filterListeners.add(listener)\r\n  }\r\n\r\n  public removeFilterListener(config: { dataset: string }, listener: any) {\r\n    try {\r\n      if (this.datasets[config.dataset].filterListeners) {\r\n        this.datasets[config.dataset].filterListeners.delete(listener)\r\n      }\r\n    } catch (e) {\r\n      // doesn't matter\r\n    }\r\n  }\r\n\r\n  public clearCache() {\r\n    this.kill() // any stragglers must die\r\n    this.datasets = {}\r\n    this.networks = {}\r\n  }\r\n\r\n  // ---- PRIVATE STUFFS -----------------------\r\n\r\n  private async _updateFilters(datasetId: string) {\r\n    console.log('> updateFilters ', datasetId)\r\n    const metaData = this.datasets[datasetId]\r\n    console.log({ metaData })\r\n\r\n    if (!Object.keys(metaData.activeFilters).length) {\r\n      console.log('no keys')\r\n      metaData.filteredRows = null\r\n      this._notifyListeners(datasetId)\r\n      return\r\n    }\r\n\r\n    // Let's do this the stupid way first, and make it better once we get it working.\r\n    const dataset = await metaData.dataset\r\n    const allColumns = Object.keys(dataset)\r\n    let filteredRows: any[] = []\r\n\r\n    const numberOfRowsInFullDataset = dataset[allColumns[0]].values.length\r\n    console.log('FILTERS:', metaData.activeFilters)\r\n    console.log('TOTLROWS', numberOfRowsInFullDataset)\r\n\r\n    // we will go thru each filter for this dataset and set the elements\r\n    // to false whenever a row fails a filter.\r\n    // This implements \"AND\" logic.\r\n    const hasMatchedFilters = new Array(numberOfRowsInFullDataset).fill(true)\r\n\r\n    const ltgt = /^(<|>)/ // starts with < or >\r\n    //            (╯° °)╯︵ ┻━┻\r\n\r\n    for (const [column, spec] of Object.entries(metaData.activeFilters)) {\r\n      const dataColumn = dataset[column]\r\n      if (spec.values[0] === undefined || spec.values[0] === '') {\r\n        globalStore.commit('error', datasetId + ': filter error')\r\n      }\r\n\r\n      // prep LT/GT\r\n      if (ltgt.test(spec.values[0])) {\r\n        if (spec.values[0].startsWith('<=')) {\r\n          spec.conditional = '<='\r\n          spec.values[0] = spec.values[0].substring(2).trim()\r\n        } else if (spec.values[0].startsWith('>=')) {\r\n          spec.conditional = '>='\r\n          spec.values[0] = spec.values[0].substring(2).trim()\r\n        } else if (spec.values[0].startsWith('<')) {\r\n          spec.conditional = '<'\r\n          spec.values[0] = spec.values[0].substring(1).trim()\r\n        } else if (spec.values[0].startsWith('>')) {\r\n          spec.conditional = '>'\r\n          spec.values[0] = spec.values[0].substring(1).trim()\r\n        }\r\n      } else {\r\n        // handle case where we are testing equal/inequal and its a \"numeric\" string\r\n        if (spec.values.length === 1 && typeof spec.values[0] === 'string') {\r\n          const numericString = parseFloat(spec.values[0])\r\n          if (Number.isFinite(numericString)) spec.values.push(numericString)\r\n        }\r\n      }\r\n\r\n      // test every row: falsify if it fails the test.\r\n      for (let i = 0; i < numberOfRowsInFullDataset; i++) {\r\n        if (!checkFilterValue(spec, dataColumn.values[i])) {\r\n          hasMatchedFilters[i] = false\r\n        }\r\n      }\r\n    }\r\n\r\n    // Build the final filtered dataset based on hasMatchedFilters\r\n    for (let i = 0; i < numberOfRowsInFullDataset; i++) {\r\n      if (hasMatchedFilters[i]) {\r\n        const row = {} as any\r\n        allColumns.forEach(col => (row[col] = dataset[col].values[i]))\r\n        filteredRows.push(row)\r\n      }\r\n    }\r\n\r\n    // For now let's leave the filtered rows as an array of data objects\r\n\r\n    // // CONVERT array of objects to column-based DataTableColumns\r\n    // const filteredDataTable: { [id: string]: DataTableColumn } = {}\r\n    // allColumns.forEach(columnId => {\r\n    //   const column = { name: columnId, values: [], type: DataType.UNKNOWN } as any\r\n    //   for (const row of filteredRows) column.values.push(row[columnId])\r\n    //   filteredDataTable[columnId] = column\r\n    // })\r\n\r\n    // metaData.filteredRows = filteredDataTable as any\r\n\r\n    metaData.filteredRows = filteredRows\r\n    this._notifyListeners(datasetId)\r\n  }\r\n\r\n  // private _checkFilterValue(\r\n  //   spec: { conditional: string; invert: boolean; values: any[] },\r\n  //   elementValue: any\r\n  // ) {\r\n  //   // lookup closure functions for < > <= >=\r\n  //   const conditionals: any = {\r\n  //     '<': () => {\r\n  //       return elementValue < spec.values[0]\r\n  //     },\r\n  //     '<=': () => {\r\n  //       return elementValue <= spec.values[0]\r\n  //     },\r\n  //     '>': () => {\r\n  //       return elementValue > spec.values[0]\r\n  //     },\r\n  //     '>=': () => {\r\n  //       return elementValue >= spec.values[0]\r\n  //     },\r\n  //   }\r\n\r\n  //   let isValueInFilterSpec: boolean\r\n\r\n  //   if (spec.conditional) {\r\n  //     isValueInFilterSpec = conditionals[spec.conditional]()\r\n  //   } else {\r\n  //     isValueInFilterSpec = spec.values.includes(elementValue)\r\n  //   }\r\n\r\n  //   if (spec.invert) return !isValueInFilterSpec\r\n  //   return isValueInFilterSpec\r\n  // }\r\n\r\n  private _notifyListeners(datasetId: string) {\r\n    const dataset = this.datasets[datasetId]\r\n    for (const notifyListener of dataset.filterListeners) {\r\n      notifyListener(datasetId)\r\n    }\r\n  }\r\n\r\n  private async _fetchDataset(config: { dataset: string }, options?: { highPrecision: boolean }) {\r\n    if (!this.files.length) {\r\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(this.subfolder)\r\n      this.files = files\r\n    }\r\n\r\n    return new Promise<DataTable>((resolve, reject) => {\r\n      const thread = new DataFetcherWorker()\r\n      this.threads.push(thread)\r\n      // console.log('NEW WORKER', thread)\r\n      try {\r\n        thread.postMessage({\r\n          fileSystemConfig: this.fileApi,\r\n          subfolder: this.subfolder,\r\n          files: this.files,\r\n          config: config,\r\n          options,\r\n        })\r\n\r\n        thread.onmessage = e => {\r\n          thread.terminate()\r\n          if (e.data.error) {\r\n            let msg = '' + e.data.error\r\n            msg = msg.replace('[object Response]', 'Error loading file')\r\n\r\n            if (config?.dataset && msg.indexOf(config.dataset) === -1) msg += `: ${config.dataset}`\r\n\r\n            globalStore.commit('setStatus', {\r\n              type: Status.ERROR,\r\n              msg,\r\n              desc: JSON.stringify(config),\r\n            })\r\n            reject()\r\n          }\r\n          resolve(e.data)\r\n        }\r\n      } catch (err) {\r\n        thread.terminate()\r\n        console.error(err)\r\n        reject(err)\r\n      }\r\n    })\r\n  }\r\n\r\n  private async _fetchNetwork(props: {\r\n    subfolder: string\r\n    filename: string\r\n    vizDetails: any\r\n    cbStatus?: any\r\n  }) {\r\n    return new Promise<NetworkLinks>(async (resolve, reject) => {\r\n      const { subfolder, filename, vizDetails, cbStatus } = props\r\n\r\n      const path = `/${subfolder}/${filename}`\r\n      console.log('load network:', path)\r\n\r\n      // get folder\r\n      let folder =\r\n        path.indexOf('/') > -1 ? path.substring(0, path.lastIndexOf('/')) : this.subfolder\r\n\r\n      // get file path search pattern\r\n      const { files } = await new HTTPFileSystem(this.fileApi).getDirectory(folder)\r\n      let pattern = path.indexOf('/') === -1 ? path : path.substring(path.lastIndexOf('/') + 1)\r\n      const match = findMatchingGlobInFiles(files, pattern)\r\n\r\n      if (match.length !== 1) reject('File not found: ' + path)\r\n\r\n      const thread = new RoadNetworkLoader() as any\r\n      try {\r\n        thread.onmessage = (e: MessageEvent) => {\r\n          // perhaps network has no CRS and we need to ask user\r\n          if (e.data.promptUserForCRS) {\r\n            let crs =\r\n              prompt('Enter the coordinate reference system, e.g. EPSG:25832') || 'EPSG:31468'\r\n            if (Number.isInteger(parseInt(crs))) crs = `EPSG:${crs}`\r\n\r\n            thread.postMessage({ crs })\r\n            return\r\n          }\r\n\r\n          // notify client of status update messages\r\n          if (e.data.status) {\r\n            if (cbStatus) cbStatus(e.data.status)\r\n            return\r\n          }\r\n\r\n          // normal exit\r\n          thread.terminate()\r\n\r\n          if (e.data.error) {\r\n            console.error(e.data.error)\r\n            reject(e.data.error)\r\n          }\r\n\r\n          resolve(e.data.links)\r\n        }\r\n\r\n        thread.postMessage({\r\n          filePath: path,\r\n          fileSystem: this.fileApi,\r\n          vizDetails,\r\n          isFirefox, // we need this for now, because Firefox bug #260\r\n        })\r\n      } catch (err) {\r\n        thread.terminate()\r\n        console.error(err)\r\n        reject(err)\r\n      }\r\n    })\r\n  }\r\n\r\n  private _getFileSystem(name: string) {\r\n    const svnProject: FileSystemConfig[] = globalStore.state.svnProjects.filter(\r\n      (a: FileSystemConfig) => a.slug === name\r\n    )\r\n    if (svnProject.length === 0) {\r\n      console.error('DDM: no such project')\r\n      throw Error\r\n    }\r\n    return svnProject[0]\r\n  }\r\n\r\n  private datasets: {\r\n    [id: string]: {\r\n      dataset: Promise<DataTable>\r\n      filteredRows: any[] | null\r\n      activeFilters: { [column: string]: any }\r\n      filterListeners: Set<any>\r\n    }\r\n  } = {}\r\n}\r\n\r\nexport function checkFilterValue(\r\n  spec: { conditional: string; invert: boolean; values: any[]; range?: boolean },\r\n  elementValue: any\r\n) {\r\n  // lookup closure functions for < > <= >=\r\n  const conditionals: any = {\r\n    '<': () => {\r\n      return elementValue < spec.values[0]\r\n    },\r\n    '<=': () => {\r\n      return elementValue <= spec.values[0]\r\n    },\r\n    '>': () => {\r\n      return elementValue > spec.values[0]\r\n    },\r\n    '>=': () => {\r\n      return elementValue >= spec.values[0]\r\n    },\r\n  }\r\n\r\n  let isValueInFilterSpec: boolean\r\n\r\n  if (spec.range) {\r\n    isValueInFilterSpec = elementValue >= spec.values[0] && elementValue <= spec.values[1]\r\n  } else if (spec.conditional) {\r\n    isValueInFilterSpec = conditionals[spec.conditional]()\r\n  } else {\r\n    isValueInFilterSpec = spec.values.includes(elementValue)\r\n  }\r\n\r\n  if (spec.invert) return !isValueInFilterSpec\r\n  return isValueInFilterSpec\r\n}\r\n"],"names":["identity","x","group","values","keys","nest","rollup","reduce","map","regroup","i","groups","InternMap","keyof","index","value","key","isChrome","isFirefox","DashboardDataManager","args","worker","config","rows","bars","columnValues","columnGroups","v","a","b","d","y","options","myDataset","allRows","column","colName","fullpath","featureProperties","fullConfig","resolve","reject","thread","DataFetcherWorker","e","globalStore","Status","err","props","filename","subfolder","vizDetails","cbStatus","path","filter","dataset","invert","range","allFilters","listener","datasetId","metaData","allColumns","filteredRows","numberOfRowsInFullDataset","hasMatchedFilters","ltgt","spec","dataColumn","numericString","checkFilterValue","row","col","notifyListener","files","HTTPFileSystem","msg","folder","pattern","findMatchingGlobInFiles","RoadNetworkLoader","crs","name","svnProject","elementValue","conditionals","isValueInFilterSpec"],"mappings":"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"}